`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 02/25/2025 04:47:38 PM
// Design Name: 
// Module Name: i2c_clk_delay
// Project Name: 
// Target Devices:  
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module i2c_clk_delay #(
    parameter DIVISOR    = 100,    // Giá trị chia cho clock hệ thống (để tạo ra clock con)
    parameter DELAY_COUNT = 50000   // Số chu kỳ của clock con cần đếm để tạo delay
)(
    input  wire clk_in,   // Clock hệ thống
    input  wire reset,    
    input  wire start,    // Kích hoạt delay
    output reg  clk_out,  // Clock sau khi chia (sử dụng cho I2C)
    output reg  delay_done  // Tín hiệu delay hoàn thành
);

    // Bộ chia clock
    reg [$clog2(DIVISOR)-1:0] clk_counter;
    reg clk_div;  // Clock nội bộ sau chia

    always @(posedge clk_in or posedge reset) begin
        if (reset) begin
            clk_counter <= 0;
            clk_div     <= 0;
        end else begin
            if (clk_counter == DIVISOR - 1) begin
                clk_counter <= 0;
                clk_div     <= ~clk_div;
            end else begin
                clk_counter <= clk_counter + 1;
            end
        end
    end

    // Xuất clk_div ra ngoài dưới dạng clk_out
    // Lưu ý: Bạn có thể chỉnh sửa nếu muốn thêm buffer hay điều chỉnh pha
    always @(posedge clk_in or posedge reset) begin
        if (reset)
            clk_out <= 0;
        else
            clk_out <= clk_div;
    end

    // Bộ đếm delay sử dụng clock con đã chia (clk_div)
    reg [$clog2(DELAY_COUNT)-1:0] delay_counter;
    reg running;

    always @(posedge clk_div or posedge reset) begin
        if (reset) begin
            delay_counter <= 0;
            delay_done    <= 0;
            running       <= 0;
        end else begin
            if (start && !running) begin
                running       <= 1;
                delay_counter <= 0;
                delay_done    <= 0;
            end else if (running) begin
                if (delay_counter == DELAY_COUNT - 1) begin
                    delay_done <= 1;
                    running    <= 0;
                end else begin
                    delay_counter <= delay_counter + 1;
                end
            end else begin
                delay_done <= 0;
            end
        end
    end

endmodule
