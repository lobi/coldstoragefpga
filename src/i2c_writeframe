`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 03/02/2025 01:13:24 PM
// Design Name: 
// Module Name: i2c_writeframe
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


//`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Module Name: i2c_writeframe
// Description: Module truyền một frame dữ liệu qua I²C. Module này tạo start
//              condition, truyền 8 bit dữ liệu, nhận ACK từ slave và tạo stop
//              condition. Được thiết kế với clock 1MHz (1µs/xung) và dùng cho bus
//              I²C của LCD (sda_lcd, scl_lcd).
//////////////////////////////////////////////////////////////////////////////////
module i2c_writeframe(
    input        clk_1MHz,    // Clock 1MHz (1µs mỗi xung)
    input        rst_n,       // Reset active low
    input        en_write,    // Kích hoạt truyền dữ liệu
    input        start_frame, // Flag tạo start condition
    input        stop_frame,  // Flag tạo stop condition
    input  [7:0] data,        // Dữ liệu 8-bit cần truyền
    inout        sda,         // Bus SDA (bidirectional)
    output reg   scl,         // Bus SCL
    output       done,        // Flag báo hiệu frame truyền xong
    output reg   sda_en       // Điều khiển drive SDA: 1 => drive, 0 => high-Z
);

    // FSM States
    localparam IDLE   = 3'd0;
    localparam START  = 3'd1;
    localparam SEND   = 3'd2;
    localparam ACK    = 3'd3;
    localparam STOP   = 3'd4;
    localparam DONE   = 3'd5;
    
    reg [2:0] state, next_state;
    reg [3:0] bit_cnt;      // Đếm 8 bit dữ liệu
    reg [7:0] shift_reg;    // Thanh ghi lưu dữ liệu cần truyền
    
    // Bộ đếm delay (sử dụng clock 1MHz, 1µs mỗi xung)
    reg [15:0] delay_cnt;
    localparam DELAY_MAX = 16'd50; // 50µs delay cho các chuyển trạng thái
    wire delay_done = (delay_cnt >= DELAY_MAX);
    
    // Bộ đếm delay
    always @(posedge clk_1MHz or negedge rst_n) begin
        if (!rst_n)
            delay_cnt <= 0;
        else if (delay_cnt < DELAY_MAX)
            delay_cnt <= delay_cnt + 1;
        else
            delay_cnt <= 0;
    end

    // FSM state register
    always @(posedge clk_1MHz or negedge rst_n) begin
        if (!rst_n)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        case(state)
            IDLE: begin
                if (en_write)
                    next_state = start_frame ? START : SEND;
                else
                    next_state = IDLE;
            end
            START: begin
                if (delay_done)
                    next_state = SEND;
                else
                    next_state = START;
            end
            SEND: begin
                if (bit_cnt == 4'd8 && delay_done)
                    next_state = ACK;
                else if (delay_done)
                    next_state = SEND;
                else
                    next_state = SEND;
            end
            ACK: begin
                if (delay_done)
                    next_state = stop_frame ? STOP : DONE;
                else
                    next_state = ACK;
            end
            STOP: begin
                if (delay_done)
                    next_state = DONE;
                else
                    next_state = STOP;
            end
            DONE: next_state = IDLE;
            default: next_state = IDLE;
        endcase
    end

    // FSM output logic
    always @(posedge clk_1MHz or negedge rst_n) begin
        if (!rst_n) begin
            scl       <= 1;
            sda_en    <= 1;
            bit_cnt   <= 0;
            shift_reg <= 8'd0;
        end else begin
            case(state)
                IDLE: begin
                    scl       <= 1;        // Bus idle: scl high
                    sda_en    <= 1;        // Drive SDA high (idle state)
                    bit_cnt   <= 0;
                    shift_reg <= data;     // Lưu dữ liệu cần truyền
                end
                START: begin
                    // Tạo start condition: khi scl high, kéo sda từ high xuống low
                    scl    <= 1;
                    sda_en <= 1;           // Drive SDA
                    // Sau delay, chuyển sda xuống low
                    if(delay_done)
                        shift_reg <= data; // Dữ liệu vẫn giữ nguyên
                end
                SEND: begin
                    // Gửi dữ liệu từng bit: xuất bit MSB trước
                    scl <= 0;            // Hạ SCL để thiết lập dữ liệu
                    sda_en <= 1;         // Drive SDA
                    // Lấy bit từ shift_reg (MSB)
                    sda_en <= 1;
                    // Khi delay đủ, chuyển SCL lên để latch bit
                    if(delay_done) begin
                        scl <= 1;
                        bit_cnt <= bit_cnt + 1;
                        shift_reg <= {shift_reg[6:0], 1'b0};
                    end
                end
                ACK: begin
                    // Thả SDA để nhận ACK từ slave
                    sda_en <= 0;
                    scl <= 1;
                end
                STOP: begin
                    // Tạo stop condition: khi scl high, sda chuyển từ low lên high
                    scl <= 1;
                    sda_en <= 1;         // Drive SDA high
                end
                DONE: begin
                    scl <= 1;
                    sda_en <= 1;
                end
                default: ;
            endcase
        end
    end

    assign done = (state == DONE);

endmodule

