`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Module: vital_sign_calculation_max30100
// Description: Dựa vào tín hiệu đã qua xử lý (filtered_data) từ MAX30100, module tính
//              toán nhịp tim (BPM) và SpO₂ (%). Các giá trị max/min (ir_max, ir_min,
//              red_max, red_min) được cập nhật trong một always block với cấu trúc if-else
//              mutually exclusive để tránh multiple drivers.
//////////////////////////////////////////////////////////////////////////////////
module vital_sign_calculation_max30100 #(
    parameter DATA_WIDTH     = 16,       // Ví dụ: 16-bit dữ liệu
    parameter COUNTER_WIDTH  = 32,       // Độ rộng của bộ đếm thời gian
    parameter CLK_FREQ       = 400000    // Tần số clock (Hz) của miền xử lý (ví dụ: 1MHz)
)(
    input  wire                      clk,
    input  wire                      reset,
    input  wire                      new_sample,    // Có mẫu mới từ raw signal processing
    input  wire                      peak_detected, // Pulse phát hiện đỉnh
    input  wire [DATA_WIDTH-1:0]     filtered_ir,   // Tín hiệu IR đã qua xử lý
    input  wire [DATA_WIDTH-1:0]     filtered_red,  // Tín hiệu Red đã qua xử lý
    output reg  [15:0]               heart_rate,    // Nhịp tim (BPM)
    output reg  [7:0]                spo2           // SpO₂ (%)
);

    //----- Tính Nhịp Tim (HR) -----
    reg [COUNTER_WIDTH-1:0] free_counter;
    reg [COUNTER_WIDTH-1:0] last_peak_time;
    wire [COUNTER_WIDTH-1:0] interval;
    assign interval = free_counter - last_peak_time;
    
    // Bộ đếm free-running
    always @(posedge clk or posedge reset) begin
        if (reset)
            free_counter <= 0;
        else
            free_counter <= free_counter + 1;
    end
    
    // Cập nhật nhịp tim khi phát hiện đỉnh
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            last_peak_time <= 0;
            heart_rate     <= 0;
        end else if (peak_detected) begin
            last_peak_time <= free_counter;
            if (interval != 0)
                heart_rate <= (60 * CLK_FREQ) / interval;
        end
    end

    //----- Tính SpO₂ và cập nhật giá trị max/min -----
    // Sử dụng cấu trúc if-else mutually exclusive để đảm bảo chỉ một nhánh drive các thanh ghi.
    reg [DATA_WIDTH-1:0] ir_max, ir_min;
    reg [DATA_WIDTH-1:0] red_max, red_min;
    reg [31:0] numerator;
    reg [31:0] denominator;
    reg [31:0] ratio;
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            ir_max  <= 0;
            ir_min  <= {DATA_WIDTH{1'b1}};
            red_max <= 0;
            red_min <= {DATA_WIDTH{1'b1}};
            spo2    <= 0;
        end
        else if (peak_detected) begin
            // Khi phát hiện đỉnh: tính toán SpO₂ dựa trên AC và DC của tín hiệu,
            // sau đó reset các giá trị max/min cho window mới.
            numerator   = (red_max - red_min) * (((ir_max + ir_min) >> 1));
            denominator = (ir_max - ir_min) * (((red_max + red_min) >> 1));
            if (denominator != 0)
                ratio = numerator / denominator;
            else
                ratio = 0;
            spo2 <= 110 - (25 * ratio[7:0]);
            // Reset lại các giá trị max/min dựa trên mẫu hiện tại
            ir_max  <= filtered_ir;
            ir_min  <= filtered_ir;
            red_max <= filtered_red;
            red_min <= filtered_red;
        end
        else if (new_sample) begin
            // Nếu không có peak_detected mà có new_sample, cập nhật giá trị max/min.
            if (filtered_ir > ir_max)
                ir_max <= filtered_ir;
            else
                ir_max <= ir_max;
                
            if (filtered_ir < ir_min)
                ir_min <= filtered_ir;
            else
                ir_min <= ir_min;
                
            if (filtered_red > red_max)
                red_max <= filtered_red;
            else
                red_max <= red_max;
                
            if (filtered_red < red_min)
                red_min <= filtered_red;
            else
                red_min <= red_min;
        end
        else begin
            // Nếu không có new_sample và không có peak_detected, giữ nguyên giá trị.
            ir_max  <= ir_max;
            ir_min  <= ir_min;
            red_max <= red_max;
            red_min <= red_min;
            spo2    <= spo2;
        end
    end

endmodule
